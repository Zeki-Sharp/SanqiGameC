# 治疗塔功能实现计划

## 项目概述

### 需求分析
根据用户需求，治疗塔应该具备以下功能：
- **治疗机制**：每隔x秒，对周围四格内的友方单位增加y点生命值
- **技能系统**：通过现有塔的技能中数值调整技能实现
- **范围治疗**：四格范围内的友方单位（包括其他塔和中心塔）

### 技术约束
- 必须基于现有的塔系统架构
- 使用现有的技能系统或数值调整机制
- 保持与现有代码的兼容性

## 现有架构分析

### 1. 塔系统架构
```
Tower (基础塔类)
├── TowerData (塔数据配置)
│   ├── TowerLevel[] (等级数据)
│   └── BulletConfig (子弹配置)
├── DamageTaker (生命值管理)
├── RangeDetector2D (范围检测)
├── BasicCaster2D (子弹发射)
└── BezierRay2D (射线传感器)
```

### 2. 技能系统现状
通过深入代码分析发现：

#### 2.1 现有技能系统架构
```
技能系统架构：
├── EffectController + EffectData (持续效果系统)
│   ├── 支持持续效果和定时效果
│   ├── 支持数值调整（modifier）
│   └── 支持特效和音效
├── ItemConfig + ItemData<T> (数值调整系统)
│   ├── PermanentItemConfig (永久增益)
│   ├── TemmporaryItemConfig (临时增益)
│   └── 支持绝对值和百分比调整
├── BulletEffectDispatcher (子弹效果分发)
│   ├── 子弹命中后分发效果
│   └── 与EffectController集成
└── IAttackBehavior (攻击行为系统)
    ├── MeleeAttackBehavior (近战攻击)
    └── RangedAttackBehavior (远程攻击)
```

#### 2.2 治疗效果支持现状
- **DamageTaker**：已有生命值管理，但**缺少Heal()方法**
- **BattleBuffType**：已有 `HealEffect` 枚举值
- **EffectController**：支持持续效果和定时效果，但**只支持Speed效果**
- **Item系统**：治疗效果只是打印日志，**没有实际应用逻辑**

### 3. 关键发现
**治疗功能需要完整实现，现有系统只是框架，缺少核心逻辑！**

## 技术方案设计

### 方案：基于等级化技能配置的治疗塔系统

#### 1.1 架构设计
```
治疗塔 = 普通塔 + 等级化治疗技能配置
├── Tower (基础塔类)
├── TowerData (塔数据配置)
│   ├── TowerLevel[] (等级数据)
│   │   ├── 基础属性 (生命值、攻击力等)
│   │   └── 治疗技能配置 (治疗量、间隔、范围等)
│   └── BulletConfig (子弹配置)
├── EffectController (效果系统扩展)
│   ├── 支持治疗效果类型
│   └── 支持定时触发治疗
├── DamageTaker (生命值管理扩展)
│   └── 添加Heal()方法
└── 治疗范围检测系统
    └── 四格范围友方单位识别
```

#### 1.2 等级化技能配置设计
```
TowerLevel 结构扩展：
├── 现有属性
│   ├── towerSprite (塔图片)
│   ├── health (生命值)
│   ├── physicAttack (物理攻击)
│   ├── attackRange (攻击范围)
│   ├── attackInterval (攻击间隔)
│   └── attackSpeed (攻击速度)
└── 新增治疗技能属性
    ├── healAmount (治疗量)
    ├── healInterval (治疗间隔)
    ├── healRange (治疗范围)
    └── healEffectType (治疗效果类型)
```

#### 1.3 核心设计原则
1. **等级化配置原则**：治疗技能参数随等级变化，符合现有TowerLevel架构
2. **最小修改原则**：在现有TowerLevel结构基础上扩展，不破坏架构
3. **配置驱动**：通过ScriptableObject配置治疗参数，支持等级化调整
4. **复用现有系统**：充分利用EffectController和DamageTaker
5. **保持兼容性**：不破坏现有的塔系统架构和升级逻辑

## 实施计划

### 阶段1：扩展TowerLevel系统（1天）

#### 1.1 扩展TowerLevel结构
- [ ] 在TowerLevel中添加治疗技能配置字段
- [ ] 添加 `healAmount` (治疗量) 字段
- [ ] 添加 `healInterval` (治疗间隔) 字段
- [ ] 添加 `healRange` (治疗范围) 字段
- [ ] 添加 `healEffectType` (治疗效果类型) 字段

#### 1.2 扩展TowerData访问器
- [ ] 添加 `GetHealAmount(int level)` 方法
- [ ] 添加 `GetHealInterval(int level)` 方法
- [ ] 添加 `GetHealRange(int level)` 方法
- [ ] 添加 `GetHealEffectType(int level)` 方法

#### 1.3 扩展DamageTaker系统
- [ ] 在DamageTaker中添加 `Heal(float amount)` 方法
- [ ] 实现生命值上限检查逻辑
- [ ] 添加治疗事件回调 `onHeal`
- [ ] 确保生命值不超过最大值

### 阶段2：扩展EffectController系统（2天）

#### 2.1 实现治疗效果逻辑
- [ ] 在ActiveEffect中添加治疗效果支持
- [ ] 实现治疗效果的OnApply/OnRemove逻辑
- [ ] 支持定时治疗（使用协程或Update循环）
- [ ] 实现治疗冷却时间管理

#### 2.2 治疗范围检测
- [ ] 实现四格范围检测逻辑
- [ ] 识别友方单位（塔和中心塔）
- [ ] 优化检测性能，避免每帧检测

### 阶段3：治疗塔配置系统（1天）

#### 3.1 配置等级化治疗技能
- [ ] 在TowerLevel编辑器中显示治疗技能配置
- [ ] 配置每个等级的治疗技能参数
- [ ] 实现配置验证逻辑（治疗量>0，间隔>0，范围>0）

#### 3.2 编辑器扩展
- [ ] 扩展TowerData编辑器，在每个等级中显示治疗配置
- [ ] 实现治疗配置的验证和错误检查
- [ ] 支持治疗技能参数的等级化调整

### 阶段4：治疗效果显示和优化（1天）

#### 4.1 视觉效果
- [ ] 实现治疗范围可视化（Gizmos）
- [ ] 添加治疗特效和音效
- [ ] 显示治疗目标数量和治疗冷却

#### 4.2 性能优化
- [ ] 实现治疗目标缓存
- [ ] 优化检测频率
- [ ] 使用对象池管理特效

## 技术实现要点

### 1. TowerLevel扩展
```csharp
[Serializable]
public struct TowerLevel
{
    // 现有属性
    [PreviewField(150)]
    [SerializeField,LabelText("塔图片")] private Sprite towerSprite;
    [SerializeField,LabelText("生命值")] private float health;
    [SerializeField,LabelText("物理攻击")] private float physicAttack;
    [SerializeField,LabelText("攻击范围")] private float attackRange;
    [SerializeField] private float attackInterval;
    [SerializeField,LabelText("攻击速度")] private float attackSpeed;
    
    // 新增治疗技能属性
    [Header("治疗技能配置")]
    [SerializeField,LabelText("治疗量")] private float healAmount;
    [SerializeField,LabelText("治疗间隔")] private float healInterval;
    [SerializeField,LabelText("治疗范围")] private float healRange;
    [SerializeField,LabelText("治疗效果类型")] private HealEffectType healEffectType;
    
    // 公共属性访问器
    public float HealAmount => healAmount;
    public float HealInterval => healInterval;
    public float HealRange => healRange;
    public HealEffectType HealEffectType => healEffectType;
}

// 治疗效果类型枚举
public enum HealEffectType
{
    Instant,     // 瞬间治疗：一次性恢复固定数值生命值
    OverTime,    // 持续治疗：在指定时间内持续恢复生命值
}
```

### 2. TowerData扩展
```csharp
public class TowerData : ScriptableObject
{
    // ... 现有代码 ...
    
    // 新增治疗技能访问器
    public float GetHealAmount(int level)
    {
        if (levels == null || level < 0 || level >= levels.Length)
        {
            Debug.LogError($"无效等级 {level}，等级范围应为 0-{levels?.Length - 1 ?? 0}");
            return 0;
        }
        return levels[level].HealAmount;
    }
    
    public float GetHealInterval(int level)
    {
        if (levels == null || level < 0 || level >= levels.Length)
        {
            Debug.LogError($"无效等级 {level}，等级范围应为 0-{levels?.Length - 1 ?? 0}");
            return 0;
        }
        return levels[level].HealInterval;
    }
    
    public float GetHealRange(int level)
    {
        if (levels == null || level < 0 || level >= levels.Length)
        {
            Debug.LogError($"无效等级 {level}，等级范围应为 0-{levels?.Length - 1 ?? 0}");
            return 0;
        }
        return levels[level].HealRange;
    }
    
    public HealEffectType GetHealEffectType(int level)
    {
        if (levels == null || level < 0 || level >= levels.Length)
        {
            Debug.LogError($"无效等级 {level}，等级范围应为 0-{levels?.Length - 1 ?? 0}");
            return HealEffectType.Instant;
        }
        return levels[level].HealEffectType;
    }
}
```

### 3. DamageTaker扩展
```csharp
public virtual void Heal(float amount)
{
    float oldHealth = currentHealth;
    currentHealth = Mathf.Min(currentHealth + amount, maxHealth);
    float actualHeal = currentHealth - oldHealth;
    
    if (actualHeal > 0)
    {
        onHeal?.Invoke(actualHeal);
    }
}
```

### 4. 治疗效果系统集成
```csharp
// 在Tower类中集成治疗技能
public class Tower : MonoBehaviour
{
    // ... 现有代码 ...
    
    private void StartHealSkill()
    {
        if (towerData == null) return;
        
        float healAmount = towerData.GetHealAmount(level);
        float healInterval = towerData.GetHealInterval(level);
        float healRange = towerData.GetHealRange(level);
        HealEffectType healEffectType = towerData.GetHealEffectType(level);
        
        if (healAmount > 0 && healInterval > 0)
        {
            StartCoroutine(HealCoroutine(healAmount, healInterval, healRange, healEffectType));
        }
    }
    
    private IEnumerator HealCoroutine(float healAmount, float healInterval, float healRange, HealEffectType effectType)
    {
        while (true)
        {
            yield return new WaitForSeconds(healInterval);
            
            // 检测范围内的友方单位并治疗
            Collider2D[] hits = Physics2D.OverlapBoxAll(transform.position, 
                new Vector2(healRange, healRange), 0f);
            
            foreach (var hit in hits)
            {
                if (IsFriendlyUnit(hit.gameObject))
                {
                    var damageTaker = hit.GetComponent<DamageTaker>();
                    if (damageTaker != null)
                    {
                        damageTaker.Heal(healAmount);
                    }
                }
            }
        }
    }
    
    private bool IsFriendlyUnit(GameObject unit)
    {
        // 检查是否为友方单位（塔或中心塔）
        return unit.CompareTag("Tower") || unit.CompareTag("CenterTower");
    }
}
```

### 5. 编辑器配置示例
```csharp
// 在TowerData编辑器中，每个等级都会显示治疗技能配置
// 等级1配置示例：
Level 1:
├── 塔图片: [治疗塔基础图片]
├── 生命值: 100
├── 物理攻击: 0
├── 攻击范围: 0
├── 攻击间隔: 0
├── 攻击速度: 0
└── 治疗技能配置:
    ├── 治疗量: 10
    ├── 治疗间隔: 4.0
    ├── 治疗范围: 4.0
    └── 治疗效果类型: OverTime

// 等级2配置示例：
Level 2:
├── 塔图片: [治疗塔进阶图片]
├── 生命值: 120
├── 物理攻击: 0
├── 攻击范围: 0
├── 攻击间隔: 0
├── 攻击速度: 0
└── 治疗技能配置:
    ├── 治疗量: 15
    ├── 治疗间隔: 3.5
    ├── 治疗范围: 4.5
    └── 治疗效果类型: OverTime

// 等级3配置示例：
Level 3:
├── 塔图片: [治疗塔高级图片]
├── 生命值: 150
├── 物理攻击: 0
├── 攻击范围: 0
├── 攻击间隔: 0
├── 攻击速度: 0
└── 治疗技能配置:
    ├── 治疗量: 25
    ├── 治疗间隔: 3.0
    ├── 治疗范围: 5.0
    └── 治疗效果类型: OverTime
```

## 等级化配置示例

### 治疗塔等级配置
```yaml
HealTowerData:
  towerName: "治疗塔"
  levels:
    - level: 1
      health: 100
      healAmount: 10
      healInterval: 4.0
      healRange: 4.0
      healEffectType: OverTime
      
    - level: 2
      health: 120
      healAmount: 15
      healInterval: 3.5
      healRange: 4.5
      healEffectType: OverTime
      
    - level: 3
      health: 150
      healAmount: 25
      healInterval: 3.0
      healRange: 5.0
      healEffectType: OverTime
```

### 治疗效果类型说明
```yaml
HealEffectType:
  Instant:    # 瞬间治疗 - 一次性恢复大量生命值
  OverTime:   # 持续治疗 - 每隔固定时间恢复少量生命值
```

## 性能优化考虑

### 1. 检测优化
- 使用Physics2D.OverlapBox进行范围检测
- 实现检测结果缓存，避免重复检测
- 设置合理的检测频率（如每0.5秒检测一次）

### 2. 内存优化
- 使用对象池管理治疗特效
- 避免频繁的GC分配
- 优化协程和事件系统

### 3. 渲染优化
- 治疗范围可视化使用Gizmos（编辑器）或简单UI（运行时）
- 特效使用LOD系统

## 测试计划

### 1. 功能测试
- [ ] 治疗塔能正确治疗友方单位
- [ ] 治疗量计算正确
- [ ] 治疗间隔时间准确
- [ ] 治疗范围限制正确

### 2. 性能测试
- [ ] 多座治疗塔同时工作的性能
- [ ] 大量友方单位时的检测性能
- [ ] 内存使用情况

### 3. 兼容性测试
- [ ] 与现有塔系统的兼容性
- [ ] 与现有效果系统的兼容性
- [ ] 存档系统的兼容性

## 风险评估

### 1. 技术风险
- **低风险**：现有架构支持扩展
- **中风险**：性能优化需要测试验证

### 2. 兼容性风险
- **低风险**：遵循最小修改原则
- **中风险**：需要确保不影响现有功能

## 总结

通过扩展现有的**等级化TowerLevel系统**，我们可以在不破坏现有架构的情况下实现治疗塔功能。这种方案：

1. **保持架构一致性**：完全遵循现有的TowerLevel等级化设计模式
2. **等级化技能配置**：治疗技能参数随等级变化，支持升级系统
3. **最小化代码修改**：主要是在现有TowerLevel结构中添加新字段
4. **易于维护和扩展**：为未来的技能系统扩展奠定基础
5. **性能可控**：通过合理的优化策略确保性能

这种设计既满足了治疗塔的功能需求，又保持了代码的清晰性和可维护性，更重要的是**完全符合你现有的等级化塔系统架构**。

### 关键优势
- **无缝集成**：治疗技能作为塔的等级属性，与现有升级系统完全兼容
- **配置灵活**：每个等级可以配置不同的治疗参数，支持渐进式增强
- **架构统一**：不需要创建新的配置类，直接扩展现有TowerLevel结构
- **编辑器友好**：在现有的TowerData编辑器中直接配置治疗技能参数
