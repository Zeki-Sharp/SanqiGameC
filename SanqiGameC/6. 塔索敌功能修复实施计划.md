# 6. 塔索敌功能修复实施计划

## 问题分析

### 当前问题
1. **FindNearestEnemyInRange()方法被注释**：塔无法正确选择目标
2. **OnDetectCollider()缺乏冷却控制**：每次检测都立即攻击
3. **目标选择逻辑缺失**：所有塔攻击同一目标
4. **性能问题**：频繁扫描所有敌人造成性能消耗

### 核心需求
- 每个塔攻击离自己最近的敌人
- 多个塔分别攻击不同目标
- 动态切换攻击目标（出现更近目标时）
- 合理的攻击冷却时间控制
- 高效的性能优化

## 与现有系统的关系

### 现有EventBus系统
- ✅ **已实现**：通用事件总线系统（EventBus.cs）
- ✅ **已使用**：在GameStateManager、VictoryConditionChecker等中使用
- ✅ **已有事件**：EnemyDeathEventArgs、BuildPreviewEventArgs等

### 实施策略
- **不是重复建设**：扩展现有EventBus系统
- **不是新建系统**：添加新的事件类型到现有EventBus
- **不是替代关系**：复用现有架构和模式

## 技术方案设计

### 1. 目标选择策略

#### 1.1 分层检测机制
```
第一层：快速范围检测
- 使用RangeDetector2D检测范围内的敌人
- 只获取进入/离开范围的敌人列表
- 避免每帧扫描所有敌人

第二层：精确距离计算
- 只在需要攻击时计算精确距离
- 缓存当前目标及其距离
- 只在敌人状态变化时重新评估
```

#### 1.2 目标优先级规则
```
优先级1：攻击范围内最近的敌人
优先级2：如果距离相同，选择先进入范围的敌人
优先级3：当前目标死亡后，立即选择新的最近目标
```

### 2. 扩展现有EventBus系统

#### 2.1 新增事件类型
```csharp
// 敌人进入塔的攻击范围
public class EnemyEnterTowerRangeEventArgs : EventArgs
{
    public GameObject Enemy;
    public GameObject Tower;
    public float Distance;
}

// 敌人离开塔的攻击范围
public class EnemyLeaveTowerRangeEventArgs : EventArgs
{
    public GameObject Enemy;
    public GameObject Tower;
}

// 塔目标变化事件
public class TowerTargetChangedEventArgs : EventArgs
{
    public GameObject Tower;
    public GameObject OldTarget;
    public GameObject NewTarget;
}

// 塔攻击冷却就绪事件
public class TowerAttackReadyEventArgs : EventArgs
{
    public GameObject Tower;
    public GameObject Target;
}
```

#### 2.2 事件发布模式
```csharp
// 使用现有EventBus发布事件
EventBus.Instance.Publish(new EnemyEnterTowerRangeEventArgs(enemy, tower, distance));

// 使用现有EventBus订阅事件
EventBus.Instance.Subscribe<EnemyEnterTowerRangeEventArgs>(OnEnemyEnterRange);
EventBus.Instance.Subscribe<EnemyDeathEventArgs>(OnEnemyDeath);
```

### 3. 性能优化策略

#### 3.1 利用现有系统优化
```
基于现有Tilemap网格：
- 使用现有的cellSize = 1f网格系统
- 利用RangeDetector2D进行范围检测
- 使用现有的CoordinateUtility进行坐标转换

优化策略：
- 塔只检测攻击范围内的敌人（已有RangeDetector2D）
- 利用现有Tilemap的cell坐标系统
- 避免重复建设网格系统
```

#### 3.2 事件驱动 + 缓存机制
```
目标缓存：
- 缓存当前目标GameObject和距离
- 只在敌人状态变化时重新评估
- 避免每帧重新计算距离

事件驱动：
- 敌人进入范围：重新评估目标优先级
- 敌人离开范围：检查是否需要重新选择
- 敌人死亡：立即重新选择目标
- 攻击冷却：检查当前目标是否仍然最近
```

## 实施步骤

### 第一阶段：基础目标选择修复

#### 步骤1：修复FindNearestEnemyInRange方法
**目标**：实现基本的目标选择逻辑

**实现思路**：
1. 取消注释并重写方法
2. 使用RangeDetector2D获取范围内的敌人
3. 计算每个敌人到塔的距离
4. 选择最近的敌人作为目标
5. 添加目标有效性检查

**关键代码结构**：
```csharp
private GameObject FindNearestEnemyInRange()
{
    // 1. 获取范围内的敌人
    var enemiesInRange = GetEnemiesInRange();
    
    // 2. 计算距离并选择最近目标
    GameObject nearestEnemy = null;
    float minDistance = float.MaxValue;
    
    foreach (var enemy in enemiesInRange)
    {
        float distance = Vector3.Distance(transform.position, enemy.transform.position);
        if (distance < minDistance && IsValidTarget(enemy))
        {
            minDistance = distance;
            nearestEnemy = enemy;
        }
    }
    
    return nearestEnemy;
}
```

#### 步骤2：修复OnDetectCollider方法
**目标**：实现攻击冷却控制和目标管理

**实现思路**：
1. 添加攻击冷却时间控制
2. 实现目标锁定和切换机制
3. 添加目标有效性验证
4. 实现攻击执行逻辑

**关键代码结构**：
```csharp
protected virtual void OnDetectCollider(Collider2D collider)
{
    // 1. 基础检查
    if (!IsValidForAttack()) return;
    
    // 2. 检查攻击冷却
    if (!IsAttackCooldownReady()) return;
    
    // 3. 重新评估目标
    GameObject currentTarget = FindNearestEnemyInRange();
    if (currentTarget != null)
    {
        // 4. 执行攻击
        ExecuteAttack(currentTarget);
        // 5. 重置冷却时间
        ResetAttackCooldown();
    }
}
```

### 第二阶段：扩展现有EventBus系统

#### 步骤3：创建新的事件类型
**目标**：在现有EventBus基础上添加塔索敌相关事件

**实现思路**：
1. 创建EnemyEnterTowerRangeEventArgs类
2. 创建EnemyLeaveTowerRangeEventArgs类
3. 创建TowerTargetChangedEventArgs类
4. 保持与现有EventArgs类的一致性

**事件类型结构**：
```csharp
// 在Assets/Scripts/EventSystem/目录下创建新文件
public class EnemyEnterTowerRangeEventArgs : EventArgs
{
    public GameObject Enemy;
    public GameObject Tower;
    public float Distance;
    
    public EnemyEnterTowerRangeEventArgs(GameObject enemy, GameObject tower, float distance)
    {
        Enemy = enemy;
        Tower = tower;
        Distance = distance;
    }
}
```

#### 步骤4：在Tower中集成事件系统
**目标**：使用现有EventBus发布和订阅事件

**实现思路**：
1. 在Tower.Awake()中订阅相关事件
2. 在目标变化时发布事件
3. 在敌人进入/离开范围时发布事件
4. 在Tower.OnDestroy()中取消订阅

**事件集成代码**：
```csharp
private void Awake()
{
    // 现有初始化代码...
    
    // 订阅事件
    EventBus.Instance.Subscribe<EnemyEnterTowerRangeEventArgs>(OnEnemyEnterRange);
    EventBus.Instance.Subscribe<EnemyDeathEventArgs>(OnEnemyDeath);
}

private void OnDestroy()
{
    // 取消订阅事件
    if (EventBus.Instance != null)
    {
        EventBus.Instance.Unsubscribe<EnemyEnterTowerRangeEventArgs>(OnEnemyEnterRange);
        EventBus.Instance.Unsubscribe<EnemyDeathEventArgs>(OnEnemyDeath);
    }
}

private void OnEnemyEnterRange(EnemyEnterTowerRangeEventArgs e)
{
    if (e.Tower == this.gameObject)
    {
        // 重新评估目标优先级
        ReassessTargetPriority();
    }
}
```

### 第三阶段：性能优化

#### 步骤5：实现目标缓存系统
**目标**：避免重复计算，提高性能

**实现思路**：
1. 在Tower中添加目标缓存
2. 实现目标切换逻辑
3. 优化距离计算
4. 利用现有RangeDetector2D

**目标缓存结构**：
```csharp
public class TowerTargetCache
{
    public GameObject CurrentTarget { get; set; }
    public float CurrentTargetDistance { get; set; }
    public bool IsTargetValid { get; set; }
    
    public void UpdateTarget(GameObject newTarget, float distance)
    {
        CurrentTarget = newTarget;
        CurrentTargetDistance = distance;
        IsTargetValid = newTarget != null;
    }
    
    public bool ShouldSwitchTarget(GameObject newTarget, float newDistance)
    {
        // 如果当前没有目标，或者新目标更近，则切换
        return CurrentTarget == null || newDistance < CurrentTargetDistance;
    }
}
```

#### 步骤6：优化RangeDetector2D使用
**目标**：充分利用现有的范围检测系统

**实现思路**：
1. 优化RangeDetector2D的检测频率
2. 实现敌人进入/离开范围的事件通知
3. 减少不必要的范围检测
4. 利用现有的碰撞检测系统

**优化策略**：
```csharp
// 1. 调整RangeDetector2D的检测频率
rangeDetector.pulseTime = 0.1f; // 每0.1秒检测一次

// 2. 利用现有的onDetectCollider事件
protected virtual void OnDetectCollider(Collider2D collider)
{
    // 只在攻击冷却结束时重新评估目标
    if (IsAttackCooldownReady())
    {
        ReassessTarget();
    }
}

// 3. 实现目标切换逻辑
private void ReassessTarget()
{
    GameObject nearestEnemy = FindNearestEnemyInRange();
    if (nearestEnemy != null && nearestEnemy != currentTarget)
    {
        SwitchTarget(nearestEnemy);
    }
}
```

### 第四阶段：系统集成和测试

#### 步骤7：系统集成
**目标**：将所有组件整合到现有系统中

**实现思路**：
1. 修改Tower.cs集成新的事件系统
2. 修改Enemy.cs添加事件通知
3. 集成空间分区系统
4. 添加缓存机制

#### 步骤8：测试验证
**目标**：验证功能正确性和性能优化效果

**测试项目**：
1. **功能测试**：
   - 测试塔正确选择最近目标
   - 测试多个塔攻击不同目标
   - 测试目标动态切换
   - 测试攻击冷却时间控制

2. **性能测试**：
   - 测试距离计算次数减少
   - 测试内存使用优化
   - 测试帧率稳定性

3. **边界测试**：
   - 测试敌人快速移动场景
   - 测试大量敌人同时存在
   - 测试敌人死亡和重生

## 技术要点

### 1. 与现有系统集成
- 复用现有EventBus架构
- 保持与现有EventArgs类的一致性
- 遵循现有的事件发布/订阅模式

### 2. 性能优化要点
- 使用对象池减少GC压力
- 缓存计算结果避免重复计算
- 使用空间分区减少不必要的检测

### 3. 代码质量要求
- 遵循SOLID原则
- 添加详细的错误处理
- 提供充分的调试信息
- 保持代码的可维护性

## 风险评估

### 高风险
- 事件系统可能造成性能问题
- 空间分区系统可能引入复杂性
- 缓存机制可能导致内存泄漏

### 缓解措施
- 分阶段实施，每阶段充分测试
- 添加性能监控和调试工具
- 建立完善的错误处理机制
- 提供回退方案

## 成功标准

1. **功能正确性**：
   - 塔正确选择最近目标
   - 多个塔攻击不同目标
   - 目标动态切换正常工作

2. **性能要求**：
   - 距离计算次数减少80%
   - 内存使用优化30%
   - 帧率稳定在60FPS

3. **代码质量**：
   - 代码结构清晰
   - 易于维护和扩展
   - 符合Unity最佳实践 