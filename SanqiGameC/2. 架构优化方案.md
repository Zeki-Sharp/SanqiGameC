# 2. 架构优化方案（2025.07）- 修订版

## 目标
解决当前项目架构中的混乱问题，明确各组件职责，优化系统间的耦合关系，建立清晰的分层架构。

---

## 现状问题分析

### 1. 管理器职责混乱
**问题描述：**
- `GameManager` 和 `GameStateManager` 职责重叠，定位不清晰
- 管理器数量过多，缺乏统一的管理层次
- 单例模式使用不当，存在多个全局访问点

**影响：**
- 开发者难以理解各管理器的具体作用
- 系统间依赖关系复杂，难以维护
- 代码复用性差，扩展困难

### 2. 敌人生成配置混乱 ✅ 已解决
**问题描述：**
- `EnemySpawner` 既支持Inspector面板配置，又支持Config文件配置
- 配置来源不统一，容易产生冲突
- 缺乏配置验证和优先级管理

**影响：**
- 配置管理复杂，容易出错
- 调试困难，难以追踪配置来源
- 扩展性差，难以支持复杂的生成逻辑

**解决方案：**
- ✅ 移除EnemySpawner的Inspector面板waves配置
- ✅ 完全依赖RoundConfig进行配置管理
- ✅ 统一配置来源，避免冲突
- ✅ 增强调试日志，便于追踪配置来源

### 3. UI管理架构混乱
**问题描述：**
- `GameUI` 直接引用大量单个UI组件，耦合度高
- UI层次结构不清晰，缺乏统一的管理模式
- 事件处理分散，难以统一管理

**影响：**
- UI组件变更影响范围大
- 代码维护困难，难以复用
- 性能问题，频繁的UI更新

---

## 重新设计的架构方案

### 核心设计原则

#### 1. 单一全局访问点
- **只保留一个全局访问点**：`GameManager.Instance`
- **移除GameCore**：避免双重单例造成的混乱
- **统一管理器注册**：通过GameManager统一管理所有子系统

#### 2. 清晰的管理器层次
```
GameManager (游戏主管理器 - 唯一全局访问点)
├── GameStateManager (游戏状态管理)
├── RoundManager (回合管理)
├── VictoryConditionChecker (胜利条件检查)
├── UIManager (UI统一管理)
├── ShopSystem (商店系统)
├── ItemManage (物品管理)
└── EnemySpawner (敌人生成器)
```

#### 3. 职责明确分工
- **GameManager**：全局协调、管理器注册、生命周期管理
- **各功能Manager**：专注于自己的核心功能
- **UIManager**：统一管理所有UI面板和组件

---

## 优化方案设计

### 第一阶段：GameManager重构（优先级：最高）✅ 已完成

#### 1.1 重新设计GameManager架构 ✅

**核心职责：**
- 作为唯一的全局访问点
- 管理所有子系统的注册和生命周期
- 提供统一的系统访问接口
- 处理系统间的依赖关系

**设计模式：**
- 单例模式：确保全局唯一访问点
- 注册模式：动态注册和管理子系统
- 依赖注入：自动处理系统间依赖

**核心方法约定：**
```csharp
// 获取子系统
T GetSystem<T>() where T : MonoBehaviour
// 注册子系统
void RegisterSystem<T>(T system) where T : MonoBehaviour
// 初始化所有系统
void InitializeAllSystems()
// 获取游戏状态
GamePhase GetCurrentGamePhase()
```

#### 1.2 子系统注册机制 ✅

**注册流程：**
1. 各子系统在Awake中自动注册到GameManager ✅
2. GameManager统一管理所有子系统的初始化顺序 ✅
3. 提供统一的访问接口，避免直接单例访问 ✅

**访问模式：**
```csharp
// 旧方式（将被废弃）
GameStateManager.Instance.SwitchPhase(GamePhase.Combat);

// 新方式
GameManager.Instance.GetSystem<GameStateManager>().SwitchPhase(GamePhase.Combat);
// 或者提供便捷方法
GameManager.Instance.SwitchGamePhase(GamePhase.Combat);
```

#### 1.3 向后兼容性设计 ✅

**兼容策略：**
- 保留原有的 `GameManager.Instance.ShopSystem` 等属性 ✅
- 逐步迁移到新的访问模式 ✅
- 提供迁移指南和示例 ✅

**已完成的工作：**
- ✅ 重新设计GameManager架构，实现子系统注册表
- ✅ 实现子系统注册机制，各系统在Awake中自动注册
- ✅ 建立统一的访问接口GetSystem<T>()和RegisterSystem<T>()
- ✅ 保持向后兼容性，保留原有访问方式
- ✅ 清理GameCore相关代码，删除GameCore.cs和UI相关文件
- ✅ 修改所有管理器使用新的GameManager架构

### 第二阶段：UI架构重构（优先级：高）🔄 进行中

#### 2.1 建立UI分层架构

**UI架构层次：**
```
UIManager (UI管理器)
├── BuildingUIPanel (建设阶段UI)
├── CombatUIPanel (战斗阶段UI)
└── VictoryUIPanel (胜利阶段UI)
```

**核心方法约定：**
- `UIManager.ShowPanel(PanelType)` - 显示指定面板
- `UIManager.HidePanel(PanelType)` - 隐藏指定面板
- `UIManager.SwitchToPhase(GamePhase)` - 切换到指定游戏阶段的UI

#### 2.2 重构GameUI

**优化方向：**
- 移除对具体UI组件的直接引用
- 通过UIManager统一管理UI显示
- 建立UI事件系统

**职责重新定义：**
- UI面板的显示/隐藏控制
- UI事件的分发和处理
- UI状态的同步和更新

### 第三阶段：配置系统统一（优先级：高）✅ 已完成

#### 3.1 建立配置管理架构 ✅

**配置层次结构：**
```
GameConfig (游戏总配置)
├── RoundConfigs (回合配置集合) ✅
├── EnemySpawnConfigs (敌人生成配置) ✅
├── UIConfigs (UI配置)
└── VictoryConfigs (胜利条件配置) ✅
```

**配置管理方法约定：**
- `ConfigManager.LoadConfig<T>()` - 加载指定类型配置
- `ConfigManager.ValidateConfig<T>()` - 验证配置有效性
- `ConfigManager.GetConfig<T>(string key)` - 获取指定配置

#### 3.2 重构EnemySpawner配置 ✅

**优化方向：**
- ✅ 移除Inspector面板的直接配置
- ✅ 通过 `RoundConfig` ScriptableObject统一管理
- ✅ 建立配置验证和错误处理机制
- ✅ 增强调试日志，便于追踪配置来源

**已完成的工作：**
- ✅ 移除EnemySpawner的Inspector面板waves配置
- ✅ 将waves字段改为私有，不再在Inspector中显示
- ✅ 移除autoStart功能，完全由RoundManager控制
- ✅ 增强调试日志，添加配置验证
- ✅ 添加敌人数量检查和Round完成检测方法
- ✅ 统一配置来源，避免Inspector和Config冲突

### 第四阶段：事件系统优化（优先级：中）

#### 4.1 统一事件管理

**事件系统架构：**
```
EventBus (事件总线)
├── EventDispatcher (事件分发器)
├── EventFilter (事件过滤器)
└── EventQueue (事件队列)
```

**核心方法约定：**
- `EventBus.Publish<T>(T event)` - 发布事件
- `EventBus.Subscribe<T>(Action<T> handler)` - 订阅事件
- `EventBus.Unsubscribe<T>(Action<T> handler)` - 取消订阅

---

## 实施计划

### 阶段一：GameManager重构（优先级：最高）✅ 已完成
**目标：** 建立统一的全局访问点
**时间：** 1-2天
**任务：**
1. ✅ 重新设计GameManager架构
2. ✅ 实现子系统注册机制
3. ✅ 建立统一的访问接口
4. ✅ 测试基础功能

### 阶段二：UI架构重构（优先级：高）🔄 进行中
**目标：** 建立分层UI架构
**时间：** 2-3天
**任务：**
1. 🔄 创建UIManager和UI面板
2. ⏳ 重构GameUI组件
3. ⏳ 建立UI事件系统
4. ⏳ 测试UI功能

### 阶段三：配置系统统一（优先级：高）✅ 已完成
**目标：** 统一配置管理方式
**时间：** 1天
**任务：**
1. ✅ 创建配置管理架构
2. ✅ 重构EnemySpawner配置
3. ✅ 建立配置验证机制
4. ✅ 创建配置编辑器工具

### 阶段四：事件系统优化（优先级：中）
**目标：** 优化事件系统性能
**时间：** 1-2天
**任务：**
1. ⏳ 统一事件管理
2. ⏳ 实现事件池
3. ⏳ 优化事件性能
4. ⏳ 测试事件系统

---

## 技术约定

### 命名规范
- 管理器类：`XXXManager`
- 配置类：`XXXConfig`
- 面板类：`XXXPanel`
- 事件类：`XXXEventArgs`

### 方法命名约定
- 初始化：`Initialize()`
- 获取系统：`GetSystem<T>()`
- 显示/隐藏：`Show()` / `Hide()`
- 事件处理：`OnXXX()`

### 文件组织约定
```
Scripts/
├── Core/ (核心管理器)
├── Config/ (配置系统)
├── UI/ (UI系统)
│   ├── Panels/ (面板)
│   └── Components/ (组件)
├── Events/ (事件系统)
└── Utils/ (工具类)
```

---

## 关键决策点

### 1. GameManager vs GameCore
**决策：** 保留GameManager，移除GameCore
**理由：**
- 避免双重单例造成的混乱
- GameManager已有使用基础，迁移成本更低
- 更符合Unity项目的常见模式

### 2. 全局访问模式
**决策：** 统一通过GameManager.Instance访问
**理由：**
- 单一访问点，避免混乱
- 便于统一管理和调试
- 支持依赖注入和生命周期管理

### 3. UI管理方式
**决策：** 分层管理，UIManager统一控制
**理由：**
- 职责清晰，易于维护
- 支持动态UI切换
- 便于扩展新UI功能

### 4. 配置管理方式 ✅ 已决策
**决策：** 统一使用ScriptableObject配置，移除Inspector面板配置
**理由：**
- 避免配置冲突和重复
- 便于版本控制和团队协作
- 支持运行时动态加载和验证

---

## 预期收益

### 代码质量提升
- 清晰的职责分离，降低耦合度
- 统一的架构模式，提高可维护性
- 标准化的接口设计，提高可扩展性

### 开发效率提升
- 减少配置错误，提高开发效率
- 统一的UI管理，简化UI开发
- 优化的事件系统，提高性能

### 系统稳定性提升
- 配置验证机制，减少运行时错误
- 分层架构设计，提高系统稳定性
- 统一的管理模式，降低维护成本

---

## 风险评估

### 技术风险
- 重构过程中可能引入新的bug
- 配置迁移可能影响现有功能
- UI重构可能影响用户体验

### 缓解措施
- 分阶段实施，每阶段充分测试
- 保留原有配置的兼容性
- 建立完善的测试机制

---

> 本方案基于当前项目现状制定，建议按阶段逐步实施，每个阶段完成后进行充分测试和验证。 