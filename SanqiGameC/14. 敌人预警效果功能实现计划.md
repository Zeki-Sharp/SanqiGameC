# 敌人预警效果功能实现计划

## 功能概述

在战斗回合开始前，通过触手/阴影效果提示玩家下一回合中敌人的位置和强度信息。触手从敌人生成点指向中心塔，为玩家提供战术预警。

## 技术方案设计

### 1. 核心设计思路

**触手生成策略：**
- 触手从配置的敌人生成点上随机位置生成
- 每个生成区域根据敌人数量动态调整触手数量
- 触手起点在生成区域内随机分布，避免重叠
- 触手终点统一指向中心塔位置
- 触手在每个Wave结束时更新，显示下一Wave的敌人信息

**触手属性映射：**
- 触手数量 = 敌人生成点数量 × 动态调整系数
- 触手长度 = 生成点到中心塔的距离 × 敌人强度系数
- 触手粗细 = 该生成点敌人的强度（数量×血量）
- 触手颜色 = 该生成点敌人的主要类型

### 2. 系统架构

```
EnemyWarningSystem (主控制器)
├── 监听回合系统和Wave事件
├── 获取下一Wave敌人信息
├── 管理触手生命周期
└── 控制预警效果显示时机

WarningTentacle (触手实例)
├── 触手位置和属性控制
├── 随机生成位置计算
├── 触手渲染和动画
└── 生命周期管理
```

## 分步骤实施计划

### 第一阶段：基础功能实现

**目标：** 实现基本的预警提示功能

**具体内容：**
1. 创建 `EnemyWarningSystem` 脚本
   - 集成到回合系统和Wave系统中
   - 监听Wave完成事件
   - 获取下一Wave敌人信息

2. 创建 `WarningTentacle` 脚本
   - 用简单黑色矩形表示触手
   - 从生成点指向中心塔
   - 基本的显示/隐藏功能

3. 触手生成逻辑
   - 根据敌人生成点创建触手
   - 在生成区域内随机选择触手起点
   - 触手终点指向中心塔

**预期效果：** 每个Wave结束时显示下一Wave的黑色触手，触手长度和粗细反映敌人强度，Wave开始时隐藏

### 第二阶段：位置和形状优化

**目标：** 优化触手的空间分布和视觉表现

**具体内容：**
1. 触手密度控制
   - 设置最小和最大触手间距
   - 根据敌人数量动态调整触手数量
   - 避免触手过于密集

2. 触手属性映射
   - 触手粗细反映敌人强度
   - 触手长度反映敌人强度（强度越高，触手越长）
   - 触手数量反映敌人数量
   - 触手颜色区分敌人类型

3. 触手分布优化
   - 实现触手"排斥力"算法
   - 让触手在生成区域内自然分散
   - 优化触手在屏幕上的视觉效果

**预期效果：** 触手分布更合理，长度和粗细信息传达更清晰

### 第三阶段：视觉效果升级

**目标：** 添加动画效果和视觉反馈

**具体内容：**
1. Shader动画效果
   - 触手摆动和扭曲动画
   - 颜色和透明度渐变
   - 边缘模糊和阴影效果

2. 过渡动画
   - Wave切换时的触手变化过渡
   - 触手出现和消失的动画
   - 触手属性变化的平滑过渡

3. 视觉反馈优化
   - 触手强度指示器
   - 鼠标悬停显示敌人信息
   - 音效和震动效果

**预期效果：** 视觉效果更丰富，用户体验更好

### 第四阶段：交互和性能优化

**目标：** 完善交互体验和性能表现

**具体内容：**
1. 交互功能
   - 鼠标悬停显示详细敌人信息
   - 触手点击交互
   - 预警信息面板

2. 性能优化
   - 触手数量上限控制
   - 距离过远的触手简化渲染
   - 使用对象池管理触手实例

3. 配置和调试
   - 预警效果参数配置
   - 调试信息和可视化工具
   - 性能监控

**预期效果：** 系统稳定，性能良好，易于调试

## 关键技术考虑点

### 1. 触手生成算法

**随机位置生成：**
```csharp
// 在生成区域内随机选择触手起点
private Vector3 GetRandomSpawnPosition(Vector3 spawnAreaCenter, float width, float height)
{
    float randomX = Random.Range(-width/2, width/2);
    float randomY = Random.Range(-height/2, height/2);
    return spawnAreaCenter + new Vector3(randomX, randomY, 0);
}

// 计算触手长度（基于敌人强度）
private float CalculateTentacleLength(Vector3 startPos, Vector3 centerTowerPos, float enemyStrength)
{
    float baseDistance = Vector3.Distance(startPos, centerTowerPos);
    float strengthMultiplier = 1f + (enemyStrength / 1000f); // 强度系数
    return baseDistance * strengthMultiplier;
}
```

**触手密度控制：**
- 设置最小触手间距，避免重叠
- 根据生成区域大小限制最大触手数量
- 实现触手分布算法，让它们自然分散

**触手长度和粗细控制：**
- 触手长度 = 基础距离 × 敌人强度系数（强度越高，触手越长）
- 触手粗细 = 敌人强度 × 缩放系数
- 强度系数范围：1.0x - 2.0x（避免触手过长影响视觉效果）

### 2. Wave切换过渡处理

**推荐方案：淡入淡出过渡**
```
Wave结束 → 旧触手淡出(0.5s) → 新触手淡入(0.5s)
```

**实现要点：**
- 使用协程控制过渡时间
- 处理新旧触手重叠时的渲染顺序
- 平滑的透明度变化
- 在Wave间隙更新触手信息

### 3. 性能优化策略

**触手数量控制：**
- 每个生成区域最大触手数量限制
- 距离过远的触手可以简化或隐藏
- 使用LOD系统，根据距离调整渲染质量

**渲染优化：**
- 触手使用简单的几何体（矩形或线条）
- 批量渲染相似的触手
- 使用对象池避免频繁创建销毁

## 与现有系统的集成

### 1. 回合和Wave系统集成
- 监听 `RoundManager` 的Wave完成事件
- 获取下一Wave的敌人配置信息
- 与 `GameManager` 集成，统一管理

### 2. 敌人生成系统集成
- 从 `EnemySpawner` 获取生成区域信息
- 读取 `WaveData` 中的敌人配置
- 与Wave切换时机同步

### 3. 中心塔系统集成
- 获取中心塔的准确位置
- 监听中心塔状态变化
- 与塔的防御系统协调

## 风险评估和应对

### 1. 技术风险
**风险：** 触手数量过多影响性能
**应对：** 设置合理的数量上限，实现LOD系统

**风险：** 触手动画效果复杂
**应对：** 分阶段实现，先实现基础功能

### 2. 设计风险
**风险：** 触手信息传达不够清晰
**应对：** 通过用户测试调整触手属性映射

**风险：** 视觉效果过于复杂
**应对：** 保持简洁，重点突出核心信息

## 成功标准

### 1. 功能完整性
- [ ] 每个Wave结束时正确显示下一Wave的预警触手
- [ ] 触手位置与敌人生成点对应
- [ ] 触手长度和粗细正确反映敌人强度
- [ ] Wave切换时触手正确更新

### 2. 性能表现
- [ ] 触手数量在合理范围内
- [ ] 帧率保持稳定
- [ ] 内存使用合理

### 3. 用户体验
- [ ] 预警信息清晰易懂
- [ ] 视觉效果美观
- [ ] 不影响游戏操作

## 后续扩展方向

### 1. 高级预警功能
- 敌人路径预测显示
- 危险等级指示器（基于触手长度和粗细的综合评估）
- 战术建议提示
- Wave间隙的敌人威胁分析

### 2. 自定义配置
- 玩家可调整预警效果强度
- 不同预警主题选择
- 预警音效自定义

### 3. 数据分析
- 预警效果使用统计
- 玩家反应时间分析
- 预警准确性评估
- Wave间隙的战术调整行为分析

---

*本计划文档将根据实施过程中的实际情况进行调整和更新。*
